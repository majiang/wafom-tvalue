<html><head>
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>lib.pointset</title>
        </head><body>
        <h1>lib.pointset</h1>
        <!-- Generated by Ddoc from .\lib\pointset.d -->
<br><br>
<dl><dt><big><a name="Bisectable"></a>template <u>Bisectable</u>(T)</big></dt>
<dd>Test whether the type has method bisect.
<br><br>
A point-set type T is <u>Bisectable</u> if it has bisect method and bisectable property.<br><br>

</dd>
<dt><big><a name="ShiftedBasisPoints"></a>struct <u>ShiftedBasisPoints</u>(T) if (isUnsigned!(T));
</big></dt>
<dd>Digital Shifted Net over F_2.
<br><br>
<font color=red>BUGS:</font><br>
If 64 &lt;= dimensionF2, position and length being ulong, foreach (x; P) gives wrong output for p.  Always bisect in such cases, though it's rare in practice.
<br><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=green>// create non-shifted digital net
</font><font color=blue>auto</font> P = <u>ShiftedBasisPoints</u>(randomVectors!<font color=blue>uint</font>(precision, dimensionR, dimensionF2), precision);
<font color=blue>assert</font> (P.dimensionF2 == dimensionF2);
<font color=blue>assert</font> (P.dimensionR == dimensionR);
<font color=blue>assert</font> (P.precision == precision);
<font color=blue>foreach</font> (j; P.popFront) <font color=blue>assert</font> (j == 0);
<font color=blue>foreach</font> (x; P) <font color=blue>assert</font> (x.length == dimensionR);
</pre>
<br><br>

<dl><dt><big><a name="basis"></a>T[][] <u>basis</u>;
</big></dt>
<dd>baisis[i][j] = (i-th vector of <u>basis</u>)'s _j-th__ component<br><br>

</dd>
<dt><big><a name="front"></a>const T[] <u>front</u>();
<br><a name="empty"></a>const bool <u>empty</u>();
<br><a name="popFront"></a>void <u>popFront</u>();
</big></dt>
<dd>Input range primitives.<br><br>

</dd>
<dt><big><a name="bisectable"></a>const bool <u>bisectable</u>();
</big></dt>
<dd>bisectability<br><br>

</dd>
<dt><big><a name="bisect"></a>const PSBP <u>bisect</u>();
</big></dt>
<dd>Return a two-element array of ShiftedBasisPoints.
<br><br>
Outputs of elements joined together is equal as multiset to output of this.<br><br>

</dd>
<dt><big><a name="shifted"></a>const SBP <u>shifted</u>(in T[] <i>shift</i>);
<br><a name="opBinary"></a>SBP <u>opBinary</u>(string op)(in T[] <i>shift</i>);
</big></dt>
<dd>new ShiftedBasisPoints with its outputs digital-<u>shifted</u>.<br><br>

</dd>
<dt><big><a name="extended"></a>SBP <u>extended</u>(in T[] <i>vector</i>);
<br><a name="extended"></a>SBP <u>extended</u>(in T[][] <i>vectors</i>);
<br><a name="opBinary"></a>SBP <u>opBinary</u>(string op)(in T[] <i>vector</i>);
<br><a name="opBinary"></a>SBP <u>opBinary</u>(string op)(in T[][] <i>vectors</i>);
</big></dt>
<dd>new ShiftedBasisPoints <u>extended</u> by a <i>vector</i>.<br><br>

</dd>
<dt><big><a name="opBinary"></a>SBP <u>opBinary</u>(string op)(in int <i>amount</i>);
</big></dt>
<dd>ShiftedBasisPoints with its outputs bit-shifted.<br><br>

</dd>
<dt><big><a name="changePrecision"></a>SBP <u>changePrecision</u>(in size_t <i>new_precision</i>);
</big></dt>
<dd>utility for bit-shifts.<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="randomBits"></a>T <u>randomBits</u>(T)(in size_t <i>precision</i>);
</big></dt>
<dd>Return a T with random lower precision bits.<br><br>

</dd>
<dt><big><a name="randomVector"></a>T[] <u>randomVector</u>(T)(in size_t <i>precision</i>, in size_t <i>dimensionR</i>);
</big></dt>
<dd>Return an array of length dimensionR, each element is precision.randomBits.<br><br>

</dd>
<dt><big><a name="randomVectors"></a>T[][] <u>randomVectors</u>(T)(in size_t <i>precision</i>, in size_t <i>dimensionR</i>, in size_t <i>count</i>);
</big></dt>
<dd>Return an array of length count, each element is precision.randomVector(dimensionR).<br><br>

</dd>
<dt><big><a name="randomBasisPoints"></a>ShiftedBasisPoints!(T) <u>randomBasisPoints</u>(T)(in size_t <i>precision</i>, in size_t <i>dimensionR</i>, in size_t <i>dimensionF2</i>, Flag!("<i>shift</i>") <i>shift</i>);
<br><a name="nonshiftedRandomBasisPoints"></a>ShiftedBasisPoints!(T) <u>nonshiftedRandomBasisPoints</u>(T)(in size_t <i>precision</i>, in size_t <i>dimensionR</i>, in size_t <i>dimensionF2</i>);
<br><a name="shiftedRandomBasisPoints"></a>ShiftedBasisPoints!(T) <u>shiftedRandomBasisPoints</u>(T)(in size_t <i>precision</i>, in size_t <i>dimensionR</i>, in size_t <i>dimensionF2</i>);
</big></dt>
<dd>Utility for point set generation.<br><br>

</dd>
<dt><big><a name="XOR"></a>T[] <u>XOR</u>(T)(in T[] <i>x</i>, in T[] <i>y</i>);
</big></dt>
<dd>vector componentwise bitwise xor.<br><br>

</dd>
<dt><big><a name="randomPoints"></a>auto <u>randomPoints</u>(T)(in size_t <i>dimensionR</i>, in size_t <i>precision</i>, in size_t <i>dimensionF2</i>);
<br><a name="transposedBasisPoints"></a>ShiftedBasisPoints!(T) <u>transposedBasisPoints</u>(T)(in T[][] <i>basis</i>, in size_t <i>precision</i>);
</big></dt>
<dd>functions for backward compatibility.<br><br>

</dd>
<dt><big><a name="fromString"></a>auto <u>fromString</u>(T)(const(char)[] <i>line</i>);
</big></dt>
<dd>construct ShiftedBasisPoints from string.
<br><br>
In case line is a part of CSV data, ignore the first comma and the following.
The rest is interpreted as space-separated values:
    precision dimensionF2 dimensionR <basis>
where <basis> is lexicographically ordered by dimF2 and dimR.
i.e., the first dimR element is the first vector of the basis.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
    <font color=blue>assert</font> (<font color=red>"32 16 1 2147486260 1073761228 536900390 268705022 134484065 67133232 33829545 17045993 8658469 4205512 2368453 1340400 789021 161910 72838 54636"</font>
            .<u>fromString</u>!<font color=blue>uint</font>().front == [0u]);
</pre>
<br><br>
</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. </small>
        </body></html>
